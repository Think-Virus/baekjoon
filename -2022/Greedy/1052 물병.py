# N개의 물병
# 각 물병에는 물을 무한대로 부을 수 있다.
# 처음에 모든 물병에는 물이 1리터씩 들어있다.
# 지민이는 이 물병을 또 다른 장소로 옮기려고 한다. 지민이는 한 번에 K개의 물병을 옮길 수 있다.
# 지민이는 물을 낭비하기는 싫고, 이동을 한 번보다 많이 하기는 싫다.
# 지민이는 물병의 물을 적절히 재분배해서, K개를 넘지 않는 비어있지 않은 물병을 만들려고 한다.
# -> 먼저 같은 양의 물이 들어있는 물병 두 개를 고른다. 그 다음에 한 개의 물병에 다른 한 쪽에 있는 물을 모두 붓는다. 이 방법을 필요한 만큼 계속 한다.
# 이런 제약 때문에, N개로 K개를 넘지않는 비어있지 않은 물병을 만드는 것이 불가능할 수도 있다.
# 다행히도, 새로운 물병을 살 수 있다. 상점에서 사는 물병은 물이 1리터 들어있다.

# 첫째 줄에 상점에서 사야하는 물병의 최솟값을 출력한다. 만약 정답이 없을 경우에는 -1을 출력한다.

# 그냥 반복문으로 하니까 속도가 곱창나네... 함수 만들어서 map으로 처리하는 게 맞을 듯..?

# 비트 마스킹 문제라고 했으니까 그걸로 푸는 게 맞을까?
# 반복문 최대한 없애게 처리했는데도 안되니까 한 번 비트마스킹 기법으로 풀 수 있는지 시도 해보자 -> 엄두가 안남..

# 아니면 K가 짝수인지 홀수인지 확인해서 풀 수는 없을라나..? -> 불가능 Why? : 그냥 무조건 합치고 그러면 가능한데 그런 게 아니어서 불가능

# 정답 코드 확인
# N을 이진법으로 바꾸면 (ex, 13 => 1101)
# 물병: 1,1,1,1,1,1,1,1,1,1,1,1,1
# 합치기: 2,2,2,2,2,2,1
# 합치기: 4,4,4,1
# 합치기: 8,4,1
# 뭔가 규칙이 보인다.
# 결론: N을 이진법으로 바꾼 수의 1의 개수가
# 물을 최대로 합친 후의 물병의 개수이다.
# 그럼 1의 개수를 줄이고 싶으면 이진수 덧셈을 이용한다.
# -> 1011(11) + 0001(1) => 1100(12)
# -> 1100(12) + 0100(4) => 10000(16)

# 어떤 원리로 저 결론이 성립되는 걸까..?

N, K = map(int, input().split())

purchased_water_bottle_cnt = 0

while bin(N).count('1') > K:
    idx = bin(N)[::-1].index('1')
    purchased_water_bottle_cnt += 2**idx
    N += 2**idx

print(purchased_water_bottle_cnt)