"""
문제
    0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.
    덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

입력
    첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

출력
    첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.
---
또 이유는 이해 안 되는데, 규칙을 찾음
---
이해한 내용 정리
    dp[k][n] : n을 k개의 숫자로 만드는 최대 개수
    접근법 :
    점화식의 원리는 N = 20, k = 4일 때
        (20+0을 3개로 쪼갤 때 경우) + (19+1을 3개로 쪼갤 때 경우) + ... + (1+19를 3개로 쪼갤 경우) + (0+20을 3개로 쪼갤 경우) 로
        dp[k][n] = dp[k-1][0] + dp[k-1][1] + ... + dp[k-1][n-1] + dp[k-1][n]
        dp[k][n-1] = dp[k-1][0] + dp[k-1][1] + ... + dp[k-1][n-1]
        -> dp[k][n] = dp[k][n-1] + dp[k-1][n]

    +a :
        n = 3, k = 3:
            n = 3, k = 2인 경우에 n은 이미 3이므로 0만 더해주면 됨
            n = 2, k = 3인 경우에 n이 1이 부족한 상태, 즉 n+1인 것, 하지만 이미 k가 3이므로 더 이상 k를 더해줄 수 없음 -> a + b + c + 1 = a + b + (c+1)이므로,
            마지막 숫자를 원래 마지막 숫자에서 1을 더해준 값으로 대체하면 됨.
        그렇기 때문에 dp[k][n] = dp[k][n-1] + dp[k-1][n] 이와 같은 점화식이 나옴
"""


def solve():
    n, k = map(int, input().split())
    dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)]
    dp[1] = [1] * (n + 1)

    for i in range(2, k + 1):
        for j in range(n + 1):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]

    print(dp[k][n] % 1000000000)


if __name__ == '__main__':
    solve()
