# N개의 숫자 구슬이 <그림 1>과 같이 막대에 꿰어져 일자로 놓여 있다. 이들 구슬은 막대에서 빼낼 수 없고, 바꿀 수 없다.

# 이 숫자 구슬을 M개의 그룹으로 나누었을 때 각각의 그룹의 합 중 최댓값이 최소가 되도록 하려 하다.
# 예를 들어 세 그룹으로 나눈다고 할 때 <그림 2>와 같이 그룹을 나누면 그룹의 합은 각각 11, 15, 18이 되어 그 중 최댓값은 18이 되고,
# <그림 3>과 같이 나누면 각 그룹의 합은 각각 17, 12, 15가 되어 그 중 최댓값은 17이 된다.
# 숫자 구슬의 배열이 위와 같을 때는 그룹의 합 중 최댓값이 17보다 작게 만들 수는 없다.
# 그룹에 포함된 숫자 구슬의 개수는 0보다 커야 한다.

# 그룹의 합 중 최댓값이 최소가 되도록 M개의 그룹으로 나누었을 때,
# 그 최댓값과 각 그룹을 구성하는 구슬의 개수를 찾아 출력하는 프로그램을 작성하시오.

# 입력 :
# 첫째 줄에 쪽부터 차례로 주어진다구슬의 개수 N과 그룹의 수 M이 주어진다.
# # 둘째 줄에는 각 구슬이 적혀진 숫자가 왼. N은 300 이하의 자연수, M은 N이하의 자연수이며,
# 구슬에 적혀진 숫자는 100 이하의 자연수이다.

# 출력 :
# 각 그룹의 합 중 최댓값이 최소가 되도록 M개의 그룹으로 나누었을 때 그 최댓값을 첫째 줄에 출력하고,
# 둘째 줄에는 각 그룹을 구성하는 구슬의 개수를 왼쪽부터 순서대로 출력한다. 구슬의 개수를 출력할 때는 사이에 한 칸의 공백을 둔다.
# 만약 그룹의 합의 최댓값이 최소가 되도록 하는 경우가 둘 이상이라면 그 중 하나만을 출력한다.

"""
In :
8 3
5 4 2 6 9 3 8 7

Out :
17
4 2 2
"""

"""
모르겠어서 알고리즘 분류 봤는데..
    - 다이나믹 프로그래밍
    - 그리디 알고리즘
    - 이분 탐색
이분 탐색 이용해야 할 듯
"""

"""
모르겠어서 정답 코드 확인
N 개의 구슬을 M개의 그룹으로 분할하고 각 그룹들의 구슬의 값의 합의 최댓값을 최소로 만드는 문제이다.
(구슬의 값의 최댓값) ~ (구슬의 값의 총합)의 범위에서 이분 탐색을 해서 '그룹들의 구슬의 합의 최댓값이 
a 이하가 되도록 구슬을 M개의 그룹으로 나눌 수 있는가?'의 문제로 바꿀 수 있다.

이분 탐색으로 답을 찾았으면 M개의 그룹으로 분할한 후 각 그룹의 구슬의 수를 출력하면 된다.
만약 구한 그룹의 개수가 M개가 되지 않는다면 다른 그룹을 한번 더 나누어 준다.
예를 들어 M = 3이고, 각 그룹에 속한 구슬 수가 6 2라면 그룹 수가 하나 모자르므로
6을 분할해서 1 5 2로 출력하도록 하는 것이다. 

1. 이분탐색으로 구현하는 문제이다.
2. left 값을 공의 최솟값 right값을 모든공의 합으로 탐색한다.
3. 정답은 공의 최댓값보다는 커야한다.
4. (최댓값이 최소가 되도록 하는 경우가 둘 이상이라면 그 중 하나만을 출력한다.) 라고 명시되어 있기 때문에 공의 그룹이 m 보다 작을경우 공을 계속해서 쪼개준다.
"""
import math

ans = 0

n, m = map(int, input().split())
ball = list(map(int, input().split()))
lt, rt = min(ball), sum(ball)
lst = []


def groupCnt(x):
    cnt = 1
    tot = 0
    tmp = []
    ballCnt = 0
    for item in ball:
        if tot + item > x:
            cnt += 1
            tot = item
            tmp.append(ballCnt)
            ballCnt = 1
        else:
            tot += item
            ballCnt += 1
    if ballCnt:
        tmp.append(ballCnt)
    return tmp, cnt


while lt <= rt:
    mid = (lt + rt) // 2
    tmp, cnt = groupCnt(mid)
    if cnt <= m and max(ball) <= mid:
        lst = tmp
        ans = mid
        rt = mid-1
    else:
        lt = mid+1

print(ans)
while len(lst) < m:
    for i in range(len(lst)):
        if lst[i] > 1:
            tmp = lst[i]
            del lst[i]
            lst.insert(i, math.ceil(tmp/2))
            lst.insert(i, math.floor(tmp/2))
            if len(lst) == m:
                break

for x in lst:
    print(x, end=' ')