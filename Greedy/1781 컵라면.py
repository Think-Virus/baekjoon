# 상욱 조교는 동호에게 N개의 문제를 주고서, 각각의 문제를 풀었을 때 컵라면을 몇 개 줄 것인지 제시 하였다.
# 하지만 동호의 찌를듯한 자신감에 소심한 상욱 조교는 각각의 문제에 대해 데드라인을 정하였다.

"""
문제 번호   1   2   3   4   5   6   7
데드라인       1   1   3   3   2   2   6
컵라면 수   6   7   2   1   4   5   1
"""

# 위와 같은 상황에서 동호가 2, 6, 3, 1, 7, 5, 4 순으로 숙제를 한다면 2, 6, 3, 7번 문제를 시간 내에 풀어 총 15개의 컵라면을 받을 수 있다.
# 문제는 동호가 받을 수 있는 최대 컵라면 수를 구하는 것이다. 위의 예에서는 15가 최대이다.
# 문제를 푸는데는 단위 시간 1이 걸리며, 각 문제의 데드라인은 N이하의 자연수이다.
# 또, 각 문제를 풀 때 받을 수 있는 컵라면 수와 최대로 받을 수 있는 컵라면 수는 모두 2^31보다 작거나 같은 자연수이다.
# 첫 줄에 숙제의 개수 N (1 ≤ N ≤ 200,000)이 들어온다.
# 다음 줄부터 N+1번째 줄까지 i+1번째 줄에 i번째 문제에 대한 데드라인과 풀면 받을 수 있는 컵라면 수가 공백으로 구분되어 입력된다.

"""
그냥 딕셔너리 써서 데드라인 순으로 자르고 하면 쉽게 풀 수 있지 않을까..?
정렬 문제일 거 같긴 한데
정렬한다면 컵라면 수가 1순위고, 그 다음에 데드라인일라나? -> 물론 데드라인 지난 것들은 페기해야 겠지만.. 이게 맞을듯??
그럴 경우 문제가
문제 번호   1   2   3   4   5   6   7
데드라인       1   1   1   3   2   2   6
컵라면 수   1   2   1   4   4   5   1
이럴 경우에 아 컵라면 수가 우선이면 괜찮을라나??

마지막 날에 할 수 있는 건 마지막 날에 처리하자
그러면 날짜별로 큰 데드라인부터 확인..? N부터 거꾸로 내려가면 될듯
"""

"""
정답 확인

데드라인에 맞춰서 문제를 풀어 가장 많은 컵라면을 얻어야 한다.
가장 많은 컵라면을 얻기 위해 우선 데드라인을 기준으로 오름차순 정렬한다.

그리고 heapq를 이용하여 데드라인 순으로 각 문제의 컵라면 수를 heapq 리스트에 추가한다.
리스트에 추가한 후 데드라인과 리스트의 길이를 비교한다.

리스트의 길이가 데드라인 보다 크다면, 데드라인을 초과한 것으로 pop을 이용하여 리스트에 있는 원소중
컵라면 수가 가장 작은 것을 제거한다.
반복문이 끝나면 최대의 컵라면 수를 구할 수 있다.
"""
import sys
import heapq

stdin = sys.stdin
N = int(stdin.readline())
assignment_list = []
noodle_list = []

for _ in range(N) :
    assignment_list.append(list(map(int,stdin.readline().split())))

assignment_list.sort(key =lambda x:(x[0]))

for assignment in assignment_list :
    heapq.heappush(noodle_list,assignment[1])
    if len(noodle_list) > assignment[0] :
        heapq.heappop(noodle_list)
print(sum(noodle_list))

